# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This repository contains a real-time GPU tree generation system using D3D12 Work Graphs 1.1 (Mesh Nodes). It's a research implementation from the paper "Real-Time GPU Tree Generation" (High Performance Graphics 2025). The system generates and renders detailed procedural trees entirely on the GPU, producing gigabytes of geometry from kilobytes of code each frame.

**Key Innovation**: Uses GPU Work Graphs with mesh nodes to generate tree geometry procedurally in real-time, avoiding the need to store pre-baked polygon meshes. This achieves extreme compression - 51 KiB of data generates what would be 34.8 GiB as static triangle meshes.

## Running the Sample

This is NOT a standalone application. It requires the Work Graph Playground to run:

```bash
# Download or build Work Graph Playground with mesh nodes enabled
# Pre-built binaries: https://github.com/GPUOpen-LibrariesAndSDKs/WorkGraphPlayground/releases

# Run the sample
path/to/WorkGraphPlayground.exe path/to/procedural-tree-generation/ProceduralTreeGeneration.hlsl
```

**Requirements**:
- GPU and driver with D3D12 Work Graphs 1.1 (Mesh Nodes) support
- Work Graph Playground built with `PLAYGROUND_ENABLE_MESH_NODES=ON`

If building playground from source with local file references, configure with:
```bash
cmake -B build . -D PLAYGROUND_ENABLE_MESH_NODES=ON -D PLAYGROUND_COPY_TUTORIAL_MODE=copy
```

## Architecture

### Core Concept: Weber-Penn Model on GPU

The system implements an extended version of the Weber-Penn procedural tree model [WP95], adapted for GPU execution via Work Graphs. Trees are defined by hierarchical levels:

- **Level 0**: Trunk
- **Level i**: Branches that spawn from Level i-1
- **Final level**: Has leaves/needles as children

Each stem segment is generated by computing transformations (position + rotation quaternion) that form "rings", which are then tessellated into geometry.

### Main Entry Point

`procedural-tree-generation/ProceduralTreeGeneration.hlsl` - Single HLSL shader containing the entire work graph implementation.

The entry node (`EntryFunction`) initializes persistent config, handles user input (camera controls, tree type selection), and spawns:
1. Skybox rendering node
2. UI rendering node
3. Tree generation node (starting with level 0 trunk)

### Modular Header Structure

The HLSL shader includes multiple `.h` files that organize functionality:

**Core Generation**:
- `TreeGeneration.h` - Main generation logic implementing Weber-Penn algorithms
- `TreeModel.h` - Bezier splines, shape functions, tapering, flare calculations
- `TreeParameters.h` - Tree parameter structures (levels, branches, curves, leaves, fruits)
- `Records.h` - Work graph record types and data structures for node communication

**Geometry & Rendering**:
- `SplineSegment.h` - Stem segment mesh generation and tessellation
- `SplineTessellation.h` - Continuous LOD tessellation algorithms
- `Leaves.h` - Leaf/needle mesh generation with procedural detail
- `Fruits.h` - Fruit/blossom generation and rendering
- `LeafDensity.h` - Spatial leaf density calculations for pruning effects

**Utilities**:
- `Quaternion.h` - Quaternion math and compression (32-bit, 64-bit formats)
- `Camera.h` - View/projection matrix calculations
- `Shading.h` - Lighting and material functions
- `Skybox.h` - Skybox rendering
- `Config.h` - Persistent configuration state management

### Work Graph Flow

1. **Entry Node** → Creates initial tree record with root transform + seed
2. **Stem Generation Nodes** → Recursively generate branch levels:
   - Compute segment positions using Weber-Penn curve algorithms
   - Apply vertical attraction (tropism), wind simulation
   - Handle stem splitting (clones diverging from parent)
   - Spawn child branch records and leaf/fruit records
3. **Mesh Nodes** → Convert procedural data directly to renderable geometry:
   - Stem segments tessellated as tubular splines with LOD
   - Leaves/needles generated as procedural quads/strands
   - Fruits rendered as colored shapes
4. **Rasterization** → Geometry flows directly to GPU rasterizer (no intermediate memory storage)

### Key Technical Features

**Record Compression**: Transform data (position + quaternion) compressed to reduce memory traffic. Quaternions use 32-bit or 64-bit compressed formats.

**Continuous LOD**: Tessellation density adapts per-frame based on distance to camera. Automated LOD selection maintains target frame rate.

**Work Coalescing**: Multiple tree generation tasks batched to improve GPU occupancy.

**Seasonal Effects**: Single `season` parameter (0-4) controls:
- Leaf/blossom appearance and color
- Fruit growth stages
- Branch sagging under fruit weight
- Snow accumulation in winter

**Animation**: Wind simulation with speed and gust parameters. Branch bending calculated based on segment properties.

**Pruning**: LeafDensity system enables complex pruning patterns by suppressing branches in areas without sufficient space.

## Development Notes

### Code Style

- All code is HLSL (shader language), not C++
- Uses D3D12-specific features (Work Graphs, Mesh Nodes)
- Heavy use of quaternion math for rotations (see `Quaternion.h`)
- Parameters passed via `TreeParameters` structs
- Persistent state stored in `PersistentScratchBuffer` (GPU buffer persisting across frames)

### Adding New Tree Types

Tree types defined as inline parameter sets in `TreeParameters.h`. To add a type:
1. Define new `TreeParameters` structure with all levels, curves, branch counts, etc.
2. Add to tree type selection in `GetTreeParameters()` function
3. Update `TREE_TYPE_COUNT` constant

### Modifying Generation Algorithms

- **Stem curves**: Edit `GetStemCurve()` in `TreeGeneration.h`
- **Branch placement**: Modify `GetBranchPosition()` logic
- **Vertical attraction**: Adjust `AddVerticalAttraction()`
- **Wind**: Edit `GetWindBend()` and `GetWindRotation()`
- **Tessellation**: Change `SplineTessellation.h` LOD formulas

### Performance Considerations

- This code runs entirely on GPU; no CPU involvement after work graph dispatch
- Memory traffic is critical bottleneck - hence quaternion compression
- Tessellation LOD directly impacts performance; tune `maxNumTriangleRingsPerSegment` in `Records.h`
- Work coalescing factors balance parallelism vs. overhead

### References to Paper

Many functions have comments like "Weber-Penn Section 4.1" referring to:
- The Weber-Penn original paper [WP95]
- The associated research paper (gpu_tree_generation.md contains full paper text)

When modifying algorithms, consult these sections to understand the mathematical basis.
